# -*- coding: utf-8 -*-
"""VI_SVM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLfWlZsz1vUCNthlH_WEMZa0cADvYyaS
"""

from IPython import get_ipython
from IPython.display import display
# %%
!pip install rasterio
import os
import numpy as np
import pandas as pd
import rasterio
from rasterio.warp import reproject, Resampling
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder, StandardScaler

# Only the most important features from Random Forest
IMPORTANCE_DICT = {
    'TWI': 0.1114785311506568,
    'Slope': 0.09992448237583644,
    'LC_2019': 0.07584589357037792,
    'LC_2020': 0.07264457985226998,
    'LC_2016': 0.06868339128192158,
    'ndvi_2016': 0.06504572713464471,
    'LC_2017': 0.05726799921412519,
    'ndvi_2017': 0.055239717284933126,
    'LC_2018': 0.05486686409091755,
    'ndvi_2019': 0.05159100211967107,
    'ndvi_2018': 0.04670668708215117,
    'ndvi_2020': 0.04613048380127212,
    'Rain_2019': 0.03809224377354962,
    'ASPECT': 0.03643968332953618,
    'Rain_2018': 0.03333840624462764,
    'Rain_2016': 0.03080693219713554,
    'Rain_2017': 0.029734304441143316,
    'Rain_2020': 0.026163071055229935
}

CSV_PATH = r"/content/drive/MyDrive/ML_input_Important_Variables_Only.csv"
df = pd.read_csv(CSV_PATH)
print("Column names from file:")
for col in df.columns:
    print(f"'{col}'")

OUTPUT_DIR = r"/content/drive/MyDrive/SVM_outputs"
YEARS = [2016, 2017, 2018, 2019, 2020]
STATIC_FEATURES = ['FID', 'TWI', 'Slope', 'ASPECT']

def balance_classes(df, target_col):
    fire_df = df[df[target_col] == 1]
    no_fire_df = df[df[target_col] == 0]
    n_samples = min(len(fire_df), len(no_fire_df))
    balanced_df = pd.concat([
        fire_df.sample(n_samples, random_state=42),
        no_fire_df.sample(n_samples, random_state=42)
    ]).sample(frac=1, random_state=42)
    return balanced_df

def process_year(df, year):
    year_str = str(year)
    lc = f"LC_{year_str}"
    ndvi = f"ndvi_{year_str}"
    rain = f"Rain_{year_str}"
    fire_col = f"Fires_{year_str}"
    pred_col = f"FireOccurrence_Predicted_{year_str}"
    encoded_col = f"encoded_target_{year_str}"

    # Select features that exist in the importance dict
    features = STATIC_FEATURES + [lc, ndvi, rain]
    cols = features + [fire_col]

    sub_df = df[cols].dropna().copy()

    full_features = features

    label_encoder = LabelEncoder()
    sub_df[encoded_col] = label_encoder.fit_transform(sub_df[fire_col])
    balanced_df = balance_classes(sub_df, encoded_col)

    X_train = balanced_df[full_features]
    y_train = balanced_df[encoded_col]
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)

    model = SVC(kernel='rbf', C=1.0, gamma='scale')
    model.fit(X_train_scaled, y_train)

    X_full_scaled = scaler.transform(sub_df[full_features])
    predictions = model.predict(X_full_scaled)
    sub_df[pred_col] = label_encoder.inverse_transform(predictions)

    output_cols = cols + [pred_col]
    output_path = os.path.join(OUTPUT_DIR, f"svm_prediction_{year_str}.csv")
    sub_df[output_cols].to_csv(output_path, index=False)
    print(f"Saved: {output_path}")

    return model, scaler, label_encoder, features

def predict_on_rasters(model, scaler, features, weights, raster_paths, output_path, nodata=-9999):
    arrays = []
    with rasterio.open(raster_paths[0]) as ref:
        ref_crs = ref.crs
        ref_bounds = ref.bounds
        dst_transform = rasterio.transform.from_origin(ref_bounds.left, ref_bounds.top, 25, 25)
        dst_width = int((ref_bounds.right - ref_bounds.left) / 25)
        dst_height = int((ref_bounds.top - ref_bounds.bottom) / 25)
        dst_shape = (dst_height, dst_width)
        ref_meta = ref.meta.copy()
        ref_meta.update({
            'transform': dst_transform,
            'height': dst_height,
            'width': dst_width,
            'crs': ref_crs,
            'count': 1,
            'dtype': rasterio.int16,
            'nodata': nodata
        })

    for path in raster_paths:
        with rasterio.open(path) as src:
            data = np.full(dst_shape, nodata, dtype=np.float32)
            reproject(
                source=rasterio.band(src, 1),
                destination=data,
                src_transform=src.transform,
                src_crs=src.crs,
                dst_transform=dst_transform,
                dst_crs=ref_crs,
                resampling=Resampling.bilinear
            )
            arrays.append(data)

    arrays = np.stack(arrays, axis=-1)
    flat = arrays.reshape(-1, arrays.shape[-1])
    mask = np.any(flat == nodata, axis=1)
    valid = ~mask
    flat_valid = flat[valid]

    total_weight = sum(weights[f] for f in features)
    normalized_weights = np.array([weights[f] / total_weight for f in features])
    risk_index = np.dot(flat_valid, normalized_weights).reshape(-1, 1)
    X_valid = np.hstack([flat_valid])
    X_scaled = scaler.transform(X_valid)

    preds = model.predict(X_scaled)
    result = np.full(flat.shape[0], nodata, dtype=np.int16)
    result[valid] = preds
    result = result.reshape(arrays.shape[:2])

    with rasterio.open(output_path, 'w', **ref_meta) as dst:
        dst.write(result, 1)
    print(f"Raster prediction saved to: {output_path}")

def main():
    df = pd.read_csv(CSV_PATH, sep=",")
    for year in YEARS:
        try:
            print(f"\n=== Processing year {year} ===")
            model, scaler, encoder, features = process_year(df, year)

            ordered_raster_paths = []
            feature_to_raster = {
                'TWI': f"/content/drive/MyDrive/Rasters/input_TWI.tif",
                'Slope': f"/content/drive/MyDrive/Rasters/input_slope.tif",
                'ASPECT': f"/content/drive/MyDrive/Rasters/input_aspect.tif",
                f'LC_{year}': f"/content/drive/MyDrive/Rasters/Landcover_{year}.tif",
                f'ndvi_{year}': f"/content/drive/MyDrive/Rasters/NDVI_{year}.tif",
                f'Rain_{year}': f"/content/drive/MyDrive/Rasters/Rain_{year}.tif"
            }
            for feature in features:
                if feature in feature_to_raster:
                    ordered_raster_paths.append(feature_to_raster[feature])
                else:
                    print(f"Warning: No raster path found for feature: {feature}")

            output_raster = fr"/content/drive/MyDrive/SVM_outputs/fire_prediction_{year}.tif"
            predict_on_rasters(model, scaler, features, IMPORTANCE_DICT, ordered_raster_paths, output_raster)

        except Exception as e:
            print(f"Error while processing {year}: {e}")

if __name__ == "__main__":
    main()